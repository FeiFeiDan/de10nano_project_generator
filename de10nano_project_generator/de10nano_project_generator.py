# Log
import logging
import sys
# re
import re
# Type
from typing import List, Tuple
# XML
from xml.dom import minidom
# path
from pathlib import Path
# signals
from signals import *
# tcl & hdl scripts
from HDL_n_Tcl import *

# globel setting
E_CLK : str = 'e_clk'           # 标准外部时钟的名称（外部时钟指的是 de10nano 通过编程的方式从 PIO 向 FPGA 发送的时钟信号）
E_CLK_EN : str = 'e_clk_en'     # 标准外部时钟enable的名称

# log
module_logger = logging.getLogger(__name__)
module_logger.setLevel(logging.INFO)
file_hander = logging.FileHandler('de10nano_project_generator.log')
stream_hander = logging.StreamHandler() # print to the console
file_hander.setLevel(logging.DEBUG)
stream_hander.setLevel(logging.INFO)
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(funcName)s - %(message)s')
file_hander.setFormatter(formatter)
stream_hander.setFormatter(formatter)
module_logger.addHandler(file_hander)
module_logger.addHandler(stream_hander)

def hdlgen_project_parser(hdlgen_project_path : str) -> Tuple[List[Port], List[str], str, str]:
    '''
    This function aims to get the information from the hdlgen project file, which is organised in XML.

    Parameters:
    - hdlgen_project_path (str): The path of the hdlgen project file, which is expect as absolute path. Relative path will work if you use this program in command line.

    Returns:
    - top_module_ports (List[Port]): The ports of users design.
    - hdl_paths (List[str]): The paths of hdl file of top module and sub module, which will return in absolute path.
    - design_name (str): The name of top module.
    - testbench (str): The testbench of top module.
    '''
    module_logger.info(f'INFO: Function hdlgen_project_parser started with parameter ---- hdlgen_project_path: {hdlgen_project_path}.')
    top_module_ports : List[Port]
    hdl_paths : List[str]
    design_name : str
    testbench : str

    project_path = Path(hdlgen_project_path)
    # First, check out whether the path exists
    assert project_path.exists(), f'ERROR: path {hdlgen_project_path} not exist.'
    
    if project_path.is_absolute():
        module_logger.info('INFO: Received a absolute path.')
    else:
        project_path = project_path.absolute()
        module_logger.info('INFO: Received a relative path.')
    project_path = project_path.as_posix() # Transfer path to posix path

    hdlgen_project = minidom.parse(project_path)
    # Get the design_name from the project xml file
    try:
        design_name = hdlgen_project.getElementsByTagName('name')[0].firstChild.data
        if design_name:
            module_logger.info(f'INFO: design_name is {design_name}.')
        else:
            module_logger.error('ERROR: No \'name\' node found.')
            raise SystemExit(1)
    except AttributeError:
        module_logger.error('ERROR: \'name\' node exists but has no child text content.')
        raise SystemExit(1)

    # Get the ioports from the project xml file
    try:
        entity_ioports_nodes = hdlgen_project.getElementsByTagName("entityIOPorts")
        if entity_ioports_nodes:
            entity_ioports = entity_ioports_nodes[0]
        else:
            module_logger.error('ERROR: No \'entityIOPorts\' node found.')
            sys.exit(1)
    except IndexError:
        module_logger.error('ERROR: \'entityIOPorts\' node not found.')
        sys.exit(1)
    for signal in entity_ioports.getElementsByTagName("signal"):
        pass

    return top_module_ports, hdl_paths, design_name, testbench

def qsys_pios_allocator(top_module_ports : list) -> List[Tuple[Port, PIO, int, int]]:
    connections : List[Tuple[Port, PIO, int, int]]
    pios : List[PIO]

    '''
    This function is to connect the ports of user's design to PIOs that generated by qsys
    '''

    return connections, pios

def project_tcl_generator(hdl_paths : List[str], output_directory : str) -> None:
    pass

def top_module_generator(
        connections : List[Tuple[Port, PIO, int, int]],
        output_directory : str,
        design_name : str) -> None:
    pass

def qsys_tcl_generator(pios : List[PIO], output_directory : str) -> None:
    pass

def project_directory_generator(output_directory : str) -> None:
    pass

def xml_file_generator(output_directory : str, design_name : str, testbench : str) -> None:
    pass

def bat_file_generator(
        output_directory : str,
        quartus_path : str,
        qsys_script_path : str,
        qsys_generate_path : str,
        quartus_cpf_path : str) -> None:
    pass

def de10nano_project_generator(
    hdlgen_project_path: str,
    output_directory: str,
    quartus_path: str,
    qsys_script_path: str,
    qsys_generate_path: str,
    quartus_cpf_path: str
) -> None:
    """
    This function automates the generation of a Quartus project and the obtainment of a programmable file.
    It creates a batch file; running it will automatically generate the Quartus project and the programmable file.

    Parameters:
    - hdlgen_project_path (str): Absolute or relative path to the hdlgen project (use absolute when integrating with HDLGen).
    - output_directory (str): Directory where you want to place the Quartus project.
    - quartus_path (str): Absolute path to the quartus.exe.
    - qsys_script_path (str): Absolute path to the qsys_script.exe.
    - qsys_generate_path (str): Absolute path to the qsys_generate.exe.
    - quartus_cpf_path (str): Absolute path to the quartus_cpf.exe.

    Step-by-step process:
    1. Parse the hdlgen project file to get:
       - top module ports
       - paths to HDL files
       - design name
       - testbench
    2. Connect ports to PIOs using qsys_pios_allocator().
    3. Create the folder structure for the Quartus project and scripts in `output_directory`.
    4. Generate the TCL script for the Quartus project that adds HDL files.
    5. Generate the top module file based on connection information.
    6. Generate the QSYS TCL script to create PIOS.
    7. Generate an XML file containing user's design info for the de10nano.
    8. Finally, generate a batch file to execute the automated project generation steps.
    """

    top_module_ports: List[Port]
    pios: List[PIO]
    connections: List[Tuple[Port, PIO, int, int]]
    hdl_paths: List[str]
    design_name: str
    testbench: str

    # Parse hdlgen project to extract necessary info
    top_module_ports, hdl_paths, design_name, testbench = hdlgen_project_parser(hdlgen_project_path)

    # Allocate and connect PIOs to ports
    connections, pios = qsys_pios_allocator(top_module_ports)

    # Prepare directories and files for Quartus project
    project_directory_generator(output_directory)

    # Generate the TCL script for adding HDL files to the project
    project_tcl_generator(hdl_paths, output_directory)

    # Generate the top module file with connection details
    top_module_generator(connections, output_directory, design_name)

    # Generate QSYS TCL script for creating PIOS
    qsys_tcl_generator(pios, output_directory)

    # Generate XML file with design and testbench info for de10nano
    xml_file_generator(output_directory, design_name, testbench)

    # Generate the batch file to automate project generation
    bat_file_generator(
        output_directory,
        quartus_path,
        qsys_script_path,
        qsys_generate_path,
        quartus_cpf_path
    )

    
    



if __name__ == '__main__':
    pass